/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Component, EventEmitter, Injectable, Injector, NgModule, Output } from '@angular/core';
import { Overlay, OverlayConfig, OverlayContainer } from '@angular/cdk/overlay';
import { ComponentPortal, PortalInjector } from '@angular/cdk/portal';
import 'rxjs/add/operator/first';
import { CommonModule } from '@angular/common';

class ContextMenuConfig {
    constructor() {
        this.items = [];
    }
}

class ContextMenuComponent {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
        this.menuActionClick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @param {?} item
     * @return {?}
     */
    onContextMenuAction(item) {
        if (!item || !item.click)
            return;
        item.click.call(this.config.context);
        this.menuActionClick.emit();
    }
}
ContextMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'app-context-menu',
                template: "<ul class=\"dropdown-menu\"><ng-container *ngFor=\"let item of config.items\"><li *ngIf=\"!item.divider\" [ngClass]=\"{disabled: item.disabled}\"><a (click)=\"onContextMenuAction(item)\">{{item.text}}</a></li><li *ngIf=\"item.divider\" role=\"separator\" class=\"divider\"></li></ng-container></ul>",
                styles: [".dropdown-menu{position:unset!important;display:unset!important}a{cursor:pointer}"]
            },] },
];
/**
 * @nocollapse
 */
ContextMenuComponent.ctorParameters = () => [
    { type: ContextMenuConfig, },
];
ContextMenuComponent.propDecorators = {
    'menuActionClick': [{ type: Output },],
};

class ContextMenuService {
    /**
     * @param {?} overlay
     * @param {?} parentInjector
     * @param {?} overlayContainer
     */
    constructor(overlay, parentInjector, overlayContainer) {
        this.overlay = overlay;
        this.parentInjector = parentInjector;
        this.overlayContainer = overlayContainer;
        let overlayConfig = new OverlayConfig();
        overlayConfig.hasBackdrop = true;
        overlayConfig.positionStrategy = overlay.position().global().left('9999px').top('9999px');
        overlayConfig.backdropClass = 'cdk-overlay-transparent-backdrop';
        this.overlayRef = overlay.create(overlayConfig);
        this.overlayRef.backdropClick().subscribe(() => this.detach());
    }
    /**
     *
     * @param {?} config
     * @return {?}
     */
    attach(config) {
        if (this.overlayRef.hasAttached()) {
            this.detach();
        }
        let /** @type {?} */ injector = this.createInjector(config), /** @type {?} */ // ContextMenuInjector(this.parentInjector, config),
        portal = new ComponentPortal(ContextMenuComponent, null, injector);
        let /** @type {?} */ componentRef = this.overlayRef.attach(portal);
        componentRef.instance.menuActionClick.first().subscribe(() => this.detach());
        setTimeout(() => {
            let /** @type {?} */ overlayElement = this.overlayRef.overlayElement, /** @type {?} */ overlayWidth = overlayElement.offsetWidth, /** @type {?} */ overlayHeight = overlayElement.offsetHeight, /** @type {?} */ containerElement = this.overlayContainer.getContainerElement(), /** @type {?} */ containerWidth = containerElement.offsetWidth, /** @type {?} */ containerHeight = containerElement.offsetHeight, /** @type {?} */ left = config.left, /** @type {?} */ top = config.top;
            left = (left + overlayWidth > containerWidth) ? containerWidth - overlayWidth : left;
            top = (top + overlayHeight > containerHeight) ? containerHeight - overlayHeight : top;
            let /** @type {?} */ positionStrategy = (this.overlayRef.getConfig().positionStrategy);
            positionStrategy.left(left + 'px').top(top + 'px');
            this.overlayRef.updatePosition();
        }, 0);
    }
    /**
     * @return {?}
     */
    detach() {
        let /** @type {?} */ positionStrategy = (this.overlayRef.getConfig().positionStrategy);
        positionStrategy.left('9999px').top('9999px');
        this.overlayRef.updatePosition();
        this.overlayRef.detach(); // .then(() => console.log('ContextMenuComponent detached'));
    }
    /**
     * @param {?} config
     * @return {?}
     */
    createInjector(config) {
        // const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
        const /** @type {?} */ injectionTokens = new WeakMap();
        injectionTokens.set(ContextMenuConfig, config);
        return new PortalInjector(/*userInjector || */ this.parentInjector, injectionTokens);
    }
}
ContextMenuService.decorators = [
    { type: Injectable },
];
/**
 * @nocollapse
 */
ContextMenuService.ctorParameters = () => [
    { type: Overlay, },
    { type: Injector, },
    { type: OverlayContainer, },
];

class ContextMenuModule {
}
ContextMenuModule.decorators = [
    { type: NgModule, args: [{
                declarations: [ContextMenuComponent],
                imports: [CommonModule],
                exports: [],
                providers: [ContextMenuService],
                entryComponents: [ContextMenuComponent]
            },] },
];
/**
 * @nocollapse
 */
ContextMenuModule.ctorParameters = () => [];

/**
 *
 */
class ContextMenuAction {
    /**
     *
     * @param {?} text
     * @param {?} click
     * @param {?=} disabled
     * @param {?=} icon
     */
    constructor(text, click, disabled, icon) {
        this.text = text;
        this.click = click;
        this.disabled = disabled;
        this.icon = icon;
        this.divider = false;
    }
}
/**
 *
 */
class ContextMenuDivider {
    constructor() {
        this.divider = true;
    }
}
const CONTEXT_MENU_DIVIDER = new ContextMenuDivider();

class ContextMenuConfigBuilder {
    constructor() {
        this.config = new ContextMenuConfig();
    }
    /**
     * @param {?} pageX
     * @return {?}
     */
    left(pageX) {
        this.config.left = pageX;
        return this;
    }
    /**
     * @param {?} pageY
     * @return {?}
     */
    top(pageY) {
        this.config.top = pageY;
        return this;
    }
    /**
     * @param {?} text
     * @param {?} click
     * @param {?=} disabled
     * @return {?}
     */
    addAction(text, click, disabled) {
        this.config.items.push(new ContextMenuAction(text, click, disabled));
        return this;
    }
    /**
     * @return {?}
     */
    addDivider() {
        do {
            if (0 === this.config.items.length)
                break;
            if (CONTEXT_MENU_DIVIDER === this.config.items[this.config.items.length - 1])
                break;
            this.config.items.push(CONTEXT_MENU_DIVIDER);
        } while (false);
        return this;
    }
    /**
     * @param {...?} items
     * @return {?}
     */
    addItems(...items) {
        this.config.items.push(...items);
        return this;
    }
    /**
     * @param {?} context
     * @return {?}
     */
    context(context) {
        this.config.context = context;
        return this;
    }
    /**
     * @return {?}
     */
    build() {
        // check menu item count
        if (0 === this.config.items.length) {
            throw new Error('empty context menu');
        }
        if (CONTEXT_MENU_DIVIDER === this.config.items[this.config.items.length - 1]) {
            this.config.items.pop();
        }
        // check again
        if (0 === this.config.items.length) {
            throw new Error('empty context menu');
        }
        if (!this.config.context) {
            console.warn('no context for ContextMenu');
        }
        return this.config;
    }
}

/**
 * Generated bundle index. Do not edit.
 */

export { ContextMenuModule, ContextMenuAction, ContextMenuDivider, CONTEXT_MENU_DIVIDER, ContextMenuConfigBuilder, ContextMenuService, ContextMenuConfig, ContextMenuComponent as Éµa };
//# sourceMappingURL=context-menu.js.map
