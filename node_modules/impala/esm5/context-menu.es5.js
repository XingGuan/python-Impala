/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Component, EventEmitter, Injectable, Injector, NgModule, Output } from '@angular/core';
import { Overlay, OverlayConfig, OverlayContainer } from '@angular/cdk/overlay';
import { ComponentPortal, PortalInjector } from '@angular/cdk/portal';
import 'rxjs/add/operator/first';
import { CommonModule } from '@angular/common';

var ContextMenuConfig = (function () {
    function ContextMenuConfig() {
        this.items = [];
    }
    return ContextMenuConfig;
}());

var ContextMenuComponent = (function () {
    /**
     * @param {?} config
     */
    function ContextMenuComponent(config) {
        this.config = config;
        this.menuActionClick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ContextMenuComponent.prototype.ngOnInit = function () {
    };
    /**
     * @param {?} item
     * @return {?}
     */
    ContextMenuComponent.prototype.onContextMenuAction = function (item) {
        if (!item || !item.click)
            return;
        item.click.call(this.config.context);
        this.menuActionClick.emit();
    };
    ContextMenuComponent.decorators = [
        { type: Component, args: [{
                    selector: 'app-context-menu',
                    template: "<ul class=\"dropdown-menu\"><ng-container *ngFor=\"let item of config.items\"><li *ngIf=\"!item.divider\" [ngClass]=\"{disabled: item.disabled}\"><a (click)=\"onContextMenuAction(item)\">{{item.text}}</a></li><li *ngIf=\"item.divider\" role=\"separator\" class=\"divider\"></li></ng-container></ul>",
                    styles: [".dropdown-menu{position:unset!important;display:unset!important}a{cursor:pointer}"]
                },] },
    ];
    /**
     * @nocollapse
     */
    ContextMenuComponent.ctorParameters = function () { return [
        { type: ContextMenuConfig, },
    ]; };
    ContextMenuComponent.propDecorators = {
        'menuActionClick': [{ type: Output },],
    };
    return ContextMenuComponent;
}());

var ContextMenuService = (function () {
    /**
     * @param {?} overlay
     * @param {?} parentInjector
     * @param {?} overlayContainer
     */
    function ContextMenuService(overlay, parentInjector, overlayContainer) {
        var _this = this;
        this.overlay = overlay;
        this.parentInjector = parentInjector;
        this.overlayContainer = overlayContainer;
        var overlayConfig = new OverlayConfig();
        overlayConfig.hasBackdrop = true;
        overlayConfig.positionStrategy = overlay.position().global().left('9999px').top('9999px');
        overlayConfig.backdropClass = 'cdk-overlay-transparent-backdrop';
        this.overlayRef = overlay.create(overlayConfig);
        this.overlayRef.backdropClick().subscribe(function () { return _this.detach(); });
    }
    /**
     *
     * @param {?} config
     * @return {?}
     */
    ContextMenuService.prototype.attach = function (config) {
        var _this = this;
        if (this.overlayRef.hasAttached()) {
            this.detach();
        }
        var /** @type {?} */ injector = this.createInjector(config), /** @type {?} */ // ContextMenuInjector(this.parentInjector, config),
        portal = new ComponentPortal(ContextMenuComponent, null, injector);
        var /** @type {?} */ componentRef = this.overlayRef.attach(portal);
        componentRef.instance.menuActionClick.first().subscribe(function () { return _this.detach(); });
        setTimeout(function () {
            var /** @type {?} */ overlayElement = _this.overlayRef.overlayElement, /** @type {?} */ overlayWidth = overlayElement.offsetWidth, /** @type {?} */ overlayHeight = overlayElement.offsetHeight, /** @type {?} */ containerElement = _this.overlayContainer.getContainerElement(), /** @type {?} */ containerWidth = containerElement.offsetWidth, /** @type {?} */ containerHeight = containerElement.offsetHeight, /** @type {?} */ left = config.left, /** @type {?} */ top = config.top;
            left = (left + overlayWidth > containerWidth) ? containerWidth - overlayWidth : left;
            top = (top + overlayHeight > containerHeight) ? containerHeight - overlayHeight : top;
            var /** @type {?} */ positionStrategy = (_this.overlayRef.getConfig().positionStrategy);
            positionStrategy.left(left + 'px').top(top + 'px');
            _this.overlayRef.updatePosition();
        }, 0);
    };
    /**
     * @return {?}
     */
    ContextMenuService.prototype.detach = function () {
        var /** @type {?} */ positionStrategy = (this.overlayRef.getConfig().positionStrategy);
        positionStrategy.left('9999px').top('9999px');
        this.overlayRef.updatePosition();
        this.overlayRef.detach(); // .then(() => console.log('ContextMenuComponent detached'));
    };
    /**
     * @param {?} config
     * @return {?}
     */
    ContextMenuService.prototype.createInjector = function (config) {
        // const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
        var /** @type {?} */ injectionTokens = new WeakMap();
        injectionTokens.set(ContextMenuConfig, config);
        return new PortalInjector(/*userInjector || */ this.parentInjector, injectionTokens);
    };
    ContextMenuService.decorators = [
        { type: Injectable },
    ];
    /**
     * @nocollapse
     */
    ContextMenuService.ctorParameters = function () { return [
        { type: Overlay, },
        { type: Injector, },
        { type: OverlayContainer, },
    ]; };
    return ContextMenuService;
}());

var ContextMenuModule = (function () {
    function ContextMenuModule() {
    }
    ContextMenuModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [ContextMenuComponent],
                    imports: [CommonModule],
                    exports: [],
                    providers: [ContextMenuService],
                    entryComponents: [ContextMenuComponent]
                },] },
    ];
    /**
     * @nocollapse
     */
    ContextMenuModule.ctorParameters = function () { return []; };
    return ContextMenuModule;
}());

/**
 *
 */
var ContextMenuAction = (function () {
    /**
     *
     * @param {?} text
     * @param {?} click
     * @param {?=} disabled
     * @param {?=} icon
     */
    function ContextMenuAction(text, click, disabled, icon) {
        this.text = text;
        this.click = click;
        this.disabled = disabled;
        this.icon = icon;
        this.divider = false;
    }
    return ContextMenuAction;
}());
/**
 *
 */
var ContextMenuDivider = (function () {
    function ContextMenuDivider() {
        this.divider = true;
    }
    return ContextMenuDivider;
}());
var CONTEXT_MENU_DIVIDER = new ContextMenuDivider();

var ContextMenuConfigBuilder = (function () {
    function ContextMenuConfigBuilder() {
        this.config = new ContextMenuConfig();
    }
    /**
     * @param {?} pageX
     * @return {?}
     */
    ContextMenuConfigBuilder.prototype.left = function (pageX) {
        this.config.left = pageX;
        return this;
    };
    /**
     * @param {?} pageY
     * @return {?}
     */
    ContextMenuConfigBuilder.prototype.top = function (pageY) {
        this.config.top = pageY;
        return this;
    };
    /**
     * @param {?} text
     * @param {?} click
     * @param {?=} disabled
     * @return {?}
     */
    ContextMenuConfigBuilder.prototype.addAction = function (text, click, disabled) {
        this.config.items.push(new ContextMenuAction(text, click, disabled));
        return this;
    };
    /**
     * @return {?}
     */
    ContextMenuConfigBuilder.prototype.addDivider = function () {
        do {
            if (0 === this.config.items.length)
                break;
            if (CONTEXT_MENU_DIVIDER === this.config.items[this.config.items.length - 1])
                break;
            this.config.items.push(CONTEXT_MENU_DIVIDER);
        } while (false);
        return this;
    };
    /**
     * @param {...?} items
     * @return {?}
     */
    ContextMenuConfigBuilder.prototype.addItems = function () {
        var items = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            items[_i] = arguments[_i];
        }
        (_a = this.config.items).push.apply(_a, items);
        return this;
        var _a;
    };
    /**
     * @param {?} context
     * @return {?}
     */
    ContextMenuConfigBuilder.prototype.context = function (context) {
        this.config.context = context;
        return this;
    };
    /**
     * @return {?}
     */
    ContextMenuConfigBuilder.prototype.build = function () {
        // check menu item count
        if (0 === this.config.items.length) {
            throw new Error('empty context menu');
        }
        if (CONTEXT_MENU_DIVIDER === this.config.items[this.config.items.length - 1]) {
            this.config.items.pop();
        }
        // check again
        if (0 === this.config.items.length) {
            throw new Error('empty context menu');
        }
        if (!this.config.context) {
            console.warn('no context for ContextMenu');
        }
        return this.config;
    };
    return ContextMenuConfigBuilder;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { ContextMenuModule, ContextMenuAction, ContextMenuDivider, CONTEXT_MENU_DIVIDER, ContextMenuConfigBuilder, ContextMenuService, ContextMenuConfig, ContextMenuComponent as Éµa };
//# sourceMappingURL=context-menu.es5.js.map
